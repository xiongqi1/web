//
// This file contains support javascript functions used by
// Titan installation assistant. Functions in this file generate
// HTML for dynamic tables
//

th_class_prefix="<th class='align12-2'>";

// A helper to convert data in bytes/second as generated by server side
// FTP measuring script to display-able string in Mbits/sec
function getThroughPutString(server_speed_data) {
    // server gives bytes per second, convert to Mbits/sec
    // Note that 1 Megabit (unlike Megabyte) is 125000 bytes
    if (isFinite(server_speed_data)) {
        var throughput = (Number(server_speed_data))/125000;
        return (throughput.toFixed(2) + " Mbps"); // AT&T wants only 2 decimal places
    } else {
        // just use the string as is from the server (could be N/A or whatever)
        return server_speed_data;
    }
}

#ifdef V_TITAN_INSTALLATION_ASSISTANT_CONN_nrb200
// Shown in Page 1 - battery section if it's available
// Generate HTML5 element (meter or progress) with battery data
function buildBatteryResult(data) {
    var battResult;

    if (!g_is_html5_supported) {
        battResult = "<p><progress value=";
        battResult += data.charge_percentage;
        battResult += " max=100></progress>";
    } else {
        battResult = "<p><meter value=";
        battResult += data.charge_percentage;
        battResult += " min=0 max=100 low=40 high=79 optimum=100></meter>";
    }
    battResult += " " + data.charge_percentage + "%" + "</p>";
    battResult += "<p>" + data.status + "</p>";
    return battResult;
}
#endif

#ifdef V_ORIENTATION_y
// Shown in Page 2 - orientation section if it's available
function buildOrientationResult(data) {
    var orientationTable = "<table>\n";
    orientationTable += "<tr>\n"
    orientationTable += th_class_prefix+"Azimuth</th>\n";
    orientationTable += th_class_prefix+"Elevation</th>\n";
    orientationTable += th_class_prefix+"Accuracy</th>\n";
    orientationTable += "</tr>\n"
    orientationTable += "<tr>\n"
    if (data.azimuth) {
        orientationTable += "<td>" + data.azimuth + " &deg;</td>\n";
    } else {
        orientationTable += "<td>N/A</td>\n";
    }
    if (data.elevation) {
        orientationTable += "<td>" + data.elevation + " &deg;</td>\n";
    } else {
        orientationTable += "<td>N/A</td>\n";
    }
    if (data.accuracy) {
        orientationTable += "<td>" + data.accuracy + "</td>\n";
    } else {
        orientationTable += "<td>N/A</td>\n";
    }
    orientationTable += "</tr>\n"
    orientationTable += "</table>";
    return orientationTable
}
#endif

// has the user entered the cell in data entry screen (return true if so).
function isUserSelectedCell(cid) {
    if (cid) {
        for (var i = 0 ; i < 3 ; i++) {
            if ((g_cid[i] !== null) && (g_cid[i] == cid)) {
                return true;
            }
        }
    }
    return false;
}

// Page 1
function buildSystemStatusContent(data) {
    var content;

    // Celluar connection status
    content = ""
    content += "<div class='box'>\n"
    content += "<div class='box-header'>\n"
    content += "<h2>Cellular Connection Status</h2>\n"
    content += "</div>\n"
    content += "<div class='box-content'>\n"
    content += "<table>\n"
    content += "<tr>\n"
    content += th_class_prefix+"SIM status</th>\n";
    content += th_class_prefix+"Network Registration Status</th>\n";
    content += "</tr>\n"
    content += "<tr>\n"
    content += "<td>" + displayAltStringIfEmpty(data.CellConn.SimStatus) + "</td>\n";
    content += "<td>" + displayAltStringIfEmpty(data.CellConn.RegStatus) + "</td>\n";
    content += "</tr>\n"
    content += "</table>\n"
    content += "</div>\n"
    content += "</div>\n"

    // WWAN connection status
    content += "<div class='box'>\n"
    content += "<div class='box-header'>\n"
    content += "<h2>WWAN Connection Status</h2>\n"
    content += "</div>\n"
    content += "<div class='box-content'>\n"
    content += "<table>\n"
    content += "<tr>\n"
    content += th_class_prefix+"APN</th>\n";
    content += th_class_prefix+"WWAN IP</th>\n";
    content += th_class_prefix+"DNS Server 1</th>\n";
    content += th_class_prefix+"DNS Server 2</th>\n";
    content += th_class_prefix+"Connection Uptime</th>\n";
    content += "</tr>\n"
    content += "<tr>\n"
    content += "<td>" + displayAltStringIfEmpty(data.WwanConn[0].APN) + "</td>\n";
    content += "<td>" + displayAltStringIfEmpty(data.WwanConn[0].IPv4Addr) + "</td>\n";
    content += "<td>" + displayAltStringIfEmpty(data.WwanConn[0].IPv4Dns1) + "</td>\n";
    content += "<td>" + displayAltStringIfEmpty(data.WwanConn[0].IPv4Dns2) + "</td>\n";
    content += "<td>" + displayAltStringIfEmpty(data.WwanConn[0].ConnUpTime) + "</td>\n";
    content += "</tr>\n"
    content += "</table>\n"
    content += "</div>\n"
    content += "</div>\n"

    // Version and other info
    content += "<div class='box'>\n"
    content += "<div class='box-header'>\n"
    content += "<h2>Versions</h2>\n"
    content += "</div>\n"
    content += "<div class='box-content'>\n"
    content += "<table>\n"
    content += "<tr>\n"
    content += th_class_prefix+"OA S/W Version</th>\n";
    content += "</tr>\n"
    content += "<tr>\n"
    content += "<td>" + displayAltStringIfEmpty(data.Versions.SwVersion) + "</td>\n";
    content += "</tr>\n"
    content += "</table>\n"
    content += "</div>\n"
    content += "</div>\n"

    return content
}

// Page 2 top part (current RF scan)
// Generate table with current RF data
// data is what comes from the server in web socket
// full_mode true means normal RF scan page, if false this is the advanced scan/status page
function buildScanResultTable(data, full_mode) {
    var scanResultTable = "<table>";
    var allowTTest = false;
    rsrp_unit_str = " (" + data.limits.RSRP.unit + ") ";
    rsrq_unit_str = " (" + data.limits.RSRQ.unit + ") ";
    scanResultTable += "<tr>\n";
    scanResultTable += th_class_prefix+"Cell sector ID</th>\n";
    scanResultTable += th_class_prefix+"Serving Cell</th>\n";
    if (full_mode) {
        scanResultTable += th_class_prefix+"Minimum RSRP</th>\n"; // although this is actually RSRP Pass level
    }
    scanResultTable += th_class_prefix+"Measure</th>\n";
    scanResultTable += th_class_prefix+"Value</th>\n";
    if (full_mode) {
        scanResultTable += th_class_prefix+"Result</th>\n";
    }
    scanResultTable += "</tr>\n";
    for (var i = 0; i < data.current_readings.length; i++) {

        // detection of serving cell
        var is_serving_cell = ((data.current_readings[i].cell_sector_id > 0) && (data.current_readings[i].cell_sector_id == data.current_readings[i].serving_cell));
        if (is_serving_cell) {
            row_span_str = "<td rowspan=3>"; // will be adding rssinr
        } else {
            row_span_str = "<td rowspan=2>";
        }
        scanResultTable += "<tr>\n";
        scanResultTable += row_span_str;
        if (data.current_readings[i].cell_sector_id) {
            scanResultTable += data.current_readings[i].cell_sector_id;
        } else {
            scanResultTable += data.current_readings[i].pci;
            scanResultTable += " (PCI)";
        }
        scanResultTable += "</td>\n";
        if (is_serving_cell) {
            scanResultTable += row_span_str + "*</td>"; // asterisk for serving cell
        }
        else {
            scanResultTable += row_span_str + " </td>"; // no asterisk otherwise
        }

        if (full_mode) { // no need to display min RSRP in advanced mode
            scanResultTable += row_span_str;
            // rsrp_pass is per PCI as user can select it, so we cannot use the global
            //scanResultTable += data.limits.RSRP.pass + rsrp_unit_str;
            scanResultTable += data.current_readings[i].rsrp_pass + " " + rsrp_unit_str;
            scanResultTable += "</td>\n";
        }
        scanResultTable += "<td>RSRP " + rsrp_unit_str + "</td>\n";
        scanResultTable += "<td";
        // only colour in full mode.
        if (full_mode) {
            if (data.current_readings[i].rsrp < data.current_readings[i].rsrp_pass) {
                scanResultTable += " class=\"red-font\"";
            } else {
                scanResultTable += " class=\"green-font\"";
            }
        }

        scanResultTable += ">";
        scanResultTable += data.current_readings[i].rsrp;
        scanResultTable += "</td>\n";

        if (full_mode) {
            scanResultTable += row_span_str;
            scanResultTable += data.current_readings[i].res;

            if (!g_is_html5_supported) {
                // progress meter needs positive values.
                scanResultTable += "<p><progress value=";
                // RSRP readings are negative. The lowest possible is -140 dBm (see data_collector).
                scanResultTable += data.current_readings[i].rsrp + 140;
                // The highest possible is -44 dBm. 140-44 is 96, so set it as max.
                scanResultTable += " max=96></progress></p>";
            } else {
                scanResultTable += "<p><meter value=";
                scanResultTable += data.current_readings[i].rsrp;
                scanResultTable += " min=";
                scanResultTable += data.limits.RSRP.min;
                scanResultTable += " max=";
                scanResultTable += data.limits.RSRP.max;
                // an interesting effect of setting the low and high to the same as "value" is
                // that the bar becomes yellow. So make it never the same.
                scanResultTable += " low=";
                scanResultTable += (data.current_readings[i].rsrp_pass - 0.0001);
                scanResultTable += " high=";
                scanResultTable += (data.current_readings[i].rsrp_pass - 0.0001);
                scanResultTable += " optimum=";
                scanResultTable += data.limits.RSRP.max;
                scanResultTable += "></meter></p>";
            }
            scanResultTable += "</td>\n";
        }
        scanResultTable += "</tr>\n";
        // add RSSINR for serving cell only
        if (is_serving_cell) {
            scanResultTable += "<td>RSSINR " + rsrq_unit_str + "</td>\n"; // can re-use rsrq units - (dB)
            scanResultTable += "<td>" + data.current_readings[i].rssinr + "</td>\n";
            scanResultTable += "</tr>\n";
        }
        scanResultTable += "<td>RSRQ " + rsrq_unit_str + "</td>\n";
        scanResultTable += "<td>" + data.current_readings[i].rsrq + "</td>\n";
        scanResultTable += "</tr>\n";
    }
    scanResultTable += "</table>";
    return [scanResultTable, data.data_connection_unavailable];
}


// Page 2 - Stats section
// Generate table with RF stats data
function buildStatsResultTable(data) {
    var statsTable = "<table>\n";

    statsTable += "<tr>\n";
    statsTable += th_class_prefix+"Cell sector ID</th>\n";
    statsTable += th_class_prefix+"Samples</th>\n";
    statsTable += "<th class='align12-2-center' colspan=3>RSRP</th>\n";
    statsTable += "<th class='align12-2-center' colspan=3>RSRQ</th>\n";
#ifdef V_ORIENTATION_y
    statsTable += "<th class='align12-2-center' colspan=3>Best Orientation</th>\n";
#endif
    statsTable += "</tr>\n";

    // the secondary (min/max) header
    statsTable += "<tr>\n";
    statsTable += "<td colspan=2></td>\n";
    statsTable += "<td>MIN</td>\n";
    statsTable += "<td>MAX</td>\n";
    statsTable += "<td>AVG</td>\n";
    statsTable += "<td>MIN</td>\n";
    statsTable += "<td>MAX</td>\n";
    statsTable += "<td>AVG</td>\n";
#ifdef V_ORIENTATION_y
    statsTable += "<td>Azimuth</td>\n";
    statsTable += "<td>Elevation</td>\n";
    statsTable += "<td>Accuracy</td>\n";
#endif
    statsTable += "</tr>\n";

    for (var i = 0; i < data.stats.length; i++) {
        statsTable += "<tr>\n";
        statsTable += "<td>";
        if (data.stats[i].cell_sector_id) {
            statsTable += data.stats[i].cell_sector_id;
        } else {
            statsTable += data.stats[i].pci;
            statsTable += " (PCI)";
        }
        statsTable += "</td>\n";
        statsTable += "<td>";
        statsTable += data.stats[i].ns;
        statsTable += "</td>\n";
        statsTable += "<td>";
        statsTable += data.stats[i].rsrp_min;
        statsTable += "</td>\n";
        statsTable += "<td>";
        statsTable += data.stats[i].rsrp_max;
        statsTable += "</td>\n";
        statsTable += "<td>";
        statsTable += data.stats[i].rsrp_avg;
        statsTable += "</td>\n";
        statsTable += "<td>";
        statsTable += data.stats[i].rsrq_min;
        statsTable += "</td>\n";
        statsTable += "<td>";
        statsTable += data.stats[i].rsrq_max;
        statsTable += "</td>\n";
        statsTable += "<td>";
        statsTable += data.stats[i].rsrq_avg;
        statsTable += "</td>\n";
#ifdef V_ORIENTATION_y
        if (data.stats[i].orientation == null) {
            statsTable += "<td>N/A</td>";
            statsTable += "<td>N/A</td>";
            statsTable += "<td>N/A</td>";
        } else {
            statsTable += "<td>";
            statsTable += data.stats[i].orientation.azimuth
            statsTable += " &deg;</td>\n";
            statsTable += "<td>";
            statsTable += data.stats[i].orientation.elevation
            statsTable += " &deg;</td>\n";
            statsTable += "<td>";
            statsTable += data.stats[i].orientation.accuracy
            statsTable += "</td>\n";
        }
#endif
        statsTable += "</tr>\n";
    }
    statsTable += "</table>";
    return statsTable;
}

// Chose correct font colour based on speed for speed text
function colourSpeedText(server_speed_data, speed_expected) {
    if (isFinite(server_speed_data) && isFinite(speed_expected)) {
        if (Number(server_speed_data) >= Number(speed_expected)) {
            return " class=\"green-font\"";
        } else {
            return " class=\"red-font\"";
        }
    } else {
        return "";
    }
}

// Work out the overall result after all tests are completed
// assume it is a pass if no more than one test repeat has failed for download and upload,
// and the average speed is ok for both.
function getOverallResult(test_data, warn_code, is_html) {

    // must match g_warning_codes in data_collector.lua
    var warn_text = [
        "", // no worries
        "Serving cell changed during the test",
        "Serving cell not entered by the operator",
        "Serving cell is not the first choice cell entered"
        ];

    var base_str = "Overall result: ";
    var res_str = ["PASS", "FAIL"];
    var html_prefix = ["<b style=\"color:green\">", "<b style=\"color:red\">", "<b style=\"color:orange\">"];
    var s = ""; // return an empty string by default
    if ((test_data.length == 2) &&
        (test_data[0].repeat_no == test_data[0].repeats) &&
        (test_data[1].repeat_no == test_data[1].repeats) &&
        (test_data[0].status == "completed") &&
        (test_data[1].status == "completed")) {
            if ((test_data[0].succ_count >= test_data[0].repeats - 1) &&
                (test_data[1].succ_count >= test_data[1].repeats - 1)) {
                s = base_str + res_str[0] + "\n";
                if (is_html) {
                    s = html_prefix[0] + s + "</b>";
                }
            } else {
                s = base_str + res_str[1] + "\n";
                if (is_html) {
                    s = html_prefix[1] + s + "</b>";
                }
            }
            if (warn_code != 0) {
                if (is_html) {
                    s += "<br>" + html_prefix[2] + warn_text[warn_code] + "</b>";
                } else {
                    s += warn_text[warn_code];
                }
            }
    }
    return s;
}

// Page 3 - throughput test
// Generate an HTML table with throughput test data on throughput test page
function buildThroughputTestResult(data) {

    var tTestResult = "<table>\n";
    tTestResult += "<tr>\n";
    tTestResult += th_class_prefix+"Test</th>\n";
    tTestResult += th_class_prefix+"Status</th>\n";
    tTestResult += th_class_prefix+"Progress</th>\n";
    tTestResult += th_class_prefix+"Speed</th>\n";
    tTestResult += "</tr>\n";

    for (var i = 0; i < data.test_data.length; i++) {
        tTestResult += "<tr>\n";
        tTestResult += "<td>";
        tTestResult += data.test_data[i].type;
        tTestResult += "</td>\n";

        tTestResult += "<td>";
        tTestResult += data.test_data[i].status;
        if (data.test_data[i].status == "completed") {
            tTestResult += " (" + data.test_data[i].repeat_no + " of " + data.test_data[i].repeats + ") ";
            tTestResult += " (" + data.test_data[i].res + ")";
        } else {
            if (data.test_data[i].status != "not started") {
                tTestResult += " (" + data.test_data[i].repeat_no + " of " + data.test_data[i].repeats + ") ";
            }
        }
        tTestResult += "</td>\n";
        tTestResult += "<td>";

        tTestResult += "<progress id=\"tt_progress_bar_id\" value=\"";
        tTestResult += data.test_data[i].value;
        tTestResult += "\" max=\"";
        tTestResult += data.test_data[i].max;
        tTestResult +="\" </progress>";
        tTestResult += "</td>\n";

        tTestResult += "<td" + colourSpeedText(data.test_data[i].avg_speed, data.test_data[i].speed_expected) + ">";
        tTestResult += getThroughPutString(data.test_data[i].avg_speed);
        tTestResult += "</td>\n";
        tTestResult += "</tr>\n";
    }
    tTestResult += "</table>";
    // use the first element
    if (data.test_data.length > 0) {
        tTestResult += "<p>Serving cell: " + data.gen_data.serving_cell + "</p>";
        tTestResult += "<p>Test start time: " + retrieveTimestamp("testStart") + "</p>";
        tTestResult += "<p>" + getOverallResult(data.test_data, data.gen_data.warning, true) + "</p>";
    } else {
        tTestResult = "<p>No test data available</p>";
    }

    return tTestResult;
}

// Special page - no valid RF data
function buildInvalidResult(data) {
    var res = "<p>" + data.message + "</p";
    return res;
}

// Page 4 (report)
// build HTML for RF stats section of final report page
function buildStatsSectionFinalReport(data) {
    var statsTable = "<table>\n";

    for (var i = 0; i < data.stats.length; i++) {
        statsTable += "<tr>\n";
        statsTable += "<td>";
        if (data.stats[i].cell_sector_id) {
            statsTable += "Cell Sector Id: " + data.stats[i].cell_sector_id;
        } else {
            statsTable += "PCI: " + data.stats[i].pci;
        }
        statsTable += "</td>\n";
        statsTable += "<td>";
        statsTable += "Average RSRP: " + data.stats[i].rsrp_avg;
        statsTable += "</td>\n";
        statsTable += "<td>";
        statsTable += "Average RSRQ: " + data.stats[i].rsrq_avg;
        statsTable += "</td>\n";
        statsTable += "<td>";
        statsTable += "Samples: " + data.stats[i].ns;
        statsTable += "</td>\n";
        statsTable += "<td>";
        statsTable += "Pass/fail: " + data.stats[i].res;
        statsTable += "</td>\n";
        statsTable += "</tr>\n";
    }
    statsTable += "</table>";
    return statsTable;
}

// Page 4 (report)
// build HTML for throughput test section of final report page
function buildTtestSectionFinalReport(data) {
    var tTestResult = "<p>Speed test:</p>";
    if (data.test_data.length == 2) {
        tTestResult += getOverallResult(data.test_data, data.gen_data.warning, true);
        tTestResult += "<p>Server used: " + data.test_data[0].server + "</p>";
        tTestResult += "<p>Method used: " + data.test_data[0].method + "</p>";
        tTestResult += "<p>Time started: " + retrieveTimestamp("testStart") + "</p>";
        d1 = Number(data.test_data[0].duration);
        d2 = Number(data.test_data[1].duration);
        if (!isNaN(d1) && !isNaN(d2)) {
            tTestResult += "<p>Duration: " + Number(d1 + d2).toFixed(2) +" seconds</p>";
        }
        tTestResult += "<p>Download speed: " + getThroughPutString(data.test_data[0].avg_speed) + "</p>";
        tTestResult += "<p>Upload speed: " + getThroughPutString(data.test_data[1].avg_speed) + "</p>";
    } else {
        tTestResult += "Unexpected result";
    }

    tTestResult += "<p>Serving Cell: " + data.gen_data.serving_cell + "</p>";
    // AT&T requested OWA IMEI number and SIM Card ICCID number and MSISDN number.
    tTestResult += "<p>IMEI: " + data.gen_data.imei + "</p>";
    tTestResult += "<p>SIM ICCID: " + data.gen_data.iccid + "</p>";
    tTestResult += "<p>SIM MSISDN: " + data.gen_data.msisdn + "</p>";
    tTestResult += "<p>OA s/w version: " + data.gen_data.sw_ver + "</p>";
    tTestResult += "<p>OA h/w version: " + data.gen_data.hw_ver + "</p>";
    tTestResult += "<p>OA AT&T S/N: " + data.gen_data.sn + "</p>";
    tTestResult += "<p>OA MAC: " + data.gen_data.mac + "</p>";
    tTestResult += "<p>OA P/N: " + data.gen_data.pn + "</p>";
    tTestResult += "<p>OA model name: " + data.gen_data.class + "</p>";
    tTestResult += "<p>Alignment tool s/w version: " + data.gen_data.sw_ver_nrb200 + "</p>";
    tTestResult += "<p>Alignment tool h/w version: " + data.gen_data.hw_ver_nrb200 + "</p>";

    return tTestResult;
}

// Page 4 (report)
// Generate test report from available data
function buildFinalReport(data) {

    if (data.rf_unavailable) {
        return buildInvalidResult(data);
    }

    // get timestamp
    var currentDate = new Date();
    var datetime = "<p>Report generated on: " + currentDate.toString() + "</p>";

    // we have all needed information in "data" object, generate correct HTML
    stats = buildStatsSectionFinalReport(data.stats_report);
    ttest = buildTtestSectionFinalReport(data.ttest_report);

    return datetime + stats + ttest;
}
