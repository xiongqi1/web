/*
 * Low pass filter
 *
 * Copyright Notice:
 * Copyright (C) 2015 NetComm Wireless limited.
 *
 * This file or portions thereof may not be copied or distributed in any form
 * (including but not limited to printed or electronic forms and binary or object forms)
 * without the expressed written consent of NetComm Wireless Ltd.
 * Copyright laws and International Treaties protect the contents of this file.
 * Unauthorized use is prohibited.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY NETCOMM WIRELESS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETCOMM
 * WIRELESS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "iir_lpfilter.h"
#include <string.h>
#if 0
static float xv[NZEROS+1], yv[NPOLES+1];


	Filter Design Results
	Generated by:   http://www-users.cs.york.ac.uk/~fisher/mkfilter

	Summary
	You specified the following parameters:

	filtertype  =       Butterworth
	passtype    =       Lowpass
	ripple      =       -36 (ignored)
	order       =       6
	samplerate  =       1
	corner1     =       0.15
	corner2     =       0.25
	adzero      =
	logmin      =       -40 (ignored)
#endif

#define GAIN   3.868375904e+02

static int64_t filter(int64_t xv[], double yv[], int64_t next_input_value) /* added */
// static void filterloop()
{
	double next_output_value; /* added */

	//for (;;) {
		xv[0] = xv[1];
		xv[1] = xv[2];
		xv[2] = xv[3];
		xv[3] = xv[4];
		xv[4] = xv[5];
		xv[5] = xv[6];
		xv[6] = next_input_value;
		yv[0] = yv[1];
		yv[1] = yv[2];
		yv[2] = yv[3];
		yv[3] = yv[4];
		yv[4] = yv[5];
		yv[5] = yv[6];
		int64_t weighted_input = (xv[0] + xv[6])
					+ 6 * (xv[1] + xv[5])
					+ 15 * (xv[2] + xv[4])
					+ 20 * xv[3];
		yv[6] =   weighted_input/GAIN
		          + ( -0.0218315740 * yv[0]) + (  0.2098654504 *
		                          yv[1])
		          + ( -0.8779238976 * yv[2]) + (  2.0551314368 *
		                          yv[3])
		          + ( -2.9104065679 * yv[4]) + (  2.3797210446 *
		                          yv[5]);
		// next output value = yv[6];
		next_output_value = yv[6]; /* added */
	//}

	return next_output_value; /* added */
}

int64_t Iir_lpfilter::filter(int64_t v)
{
	return ::filter(xv,yv,v);
}

void Iir_lpfilter::clear()
{
	/* zero memory */
	memset(this,0,sizeof(*this));
}
