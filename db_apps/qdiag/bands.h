/* LTE band and frequency calculator. Generated by bands.py, do not edit directly */
#ifndef _EARFCN_H
#define _EARFCN_H

struct lte_band {
    int band;         /* band number */
    const char *name; /* Reserved */
    float fdll;       /* Downlink low frequency */
    int ndlo;         /* Downlink EARFCN offset */
    int ndlr;         /* Downlink EARFCN block length (*0.1MHz bandwidth) */
    float full;       /* Uplink low frequency (Same as DL for TDD) */
    int nulo;         /* Uplink EARFCN offset (<0 for no uplink) */
    int nulr;         /* Uplink EARFCN block length (*0.1MHz bandwidth) */
};
#include "bands_lte.h"
#define lte_bands_no (sizeof(lte_bands) / sizeof(struct lte_band))

static inline const struct lte_band *bands_lookup_earfcn(int earfcn)
{
    int i;
    for (i = 0; i < lte_bands_no; i++) {
        // Downlink
        if (earfcn >= lte_bands[i].ndlo && earfcn < lte_bands[i].ndlo + lte_bands[i].ndlr) {
            return &lte_bands[i];
        }
        // Uplink
        if (earfcn >= lte_bands[i].nulo && earfcn < lte_bands[i].nulo + lte_bands[i].nulr) {
            return &lte_bands[i];
        }
    }
    return NULL;
}

static inline float lte_frequency(const struct lte_band *b, int earfcn)
{
    if (earfcn >= b->ndlo && earfcn < b->ndlo + b->ndlr) {
        return (b->fdll + 0.1 * (earfcn - b->ndlo));
    }
    if (earfcn >= b->nulo && earfcn < b->nulo + b->nulr) {
        return (b->full + 0.1 * (earfcn - b->nulo));
    }
    return 0.0;
}

#endif /* _EARFCN_H */
